
{
  "project_name": "BDO Market Tracker",
  "version": "0.2.3",
  "last_updated": "2025-10-12",
  "status": "ğŸ”§ IN ENTWICKLUNG - GrundfunktionalitÃ¤t implementiert, Stabilisierung lÃ¤uft",
  "structure_cleanup": "2025-10-12 - Projekt-Struktur aufgerÃ¤umt und konsolidiert",
  
  "goal": "Entwicklung eines robusten OCR-basierten Trackers fÃ¼r das Ingame-Market-Log von Black Desert Online (BDO). Der Tracker erkennt Transaktionen automatisch, unterscheidet Buy/Sell anhand von Fenstererkennung und Benutzerkontext, erfasst sie eindeutig in einer SQLite-Datenbank und bietet eine GUI fÃ¼r Analyse und Export.",

  "quick_summary": {
    "description": "OCR-basierter Market-Tracker fÃ¼r BDO mit automatischer Transaktionserkennung, Window-Detection, Delta-basierter Duplikat-Vermeidung und persistenter Baseline",
    "key_features": [
      "âœ… OCR V2: Sanftes Preprocessing fÃ¼r Game-UIs (EasyOCR + Tesseract Fallback), robust gegen fehlende Confidence-Werte",
      "âœ… 4 Window Types: sell_overview, buy_overview, sell_item, buy_item",
      "âœ… Persistent Baseline: tracker_state DB â†’ Ã¼berlebt App-Restart",
      "âœ… Historical Transaction Detection V2: Item-Kategorien fÃ¼r Buy/Sell ohne Kontext, funktioniert auch auf fremdem Tab",
      "âœ… 6 Transaction Cases: collect, relist_full, relist_partial (buy & sell)",
      "âœ… Improved Clustering: Events mit gleichem Item+Timestamp werden ZUERST gruppiert, dann Case-Resolution",
      "âœ… Smart Parsing: Timestamp-Cluster-Logik, OCR-Fehler-Korrektur, Fuzzy-Matching",
      "âœ… DB-basierte Delta-Detection: verhindert Skip von echten neuen Transaktionen",
      "âœ… GUI: Live-Window-Status, Health-Indikator (ğŸŸ¢ğŸŸ¡ğŸ”´), Filter, Export, Debug-Toggle, Analyse-Plot",
      "âœ… Fast Stop: Interruptible Sleep <200ms Reaktionszeit",
      "âœ… Test Coverage: 22/22 Tests bestehen (100%)"
    ],
    "architecture": {
      "tracker.py": "Hauptlogik - MarketTracker Klasse, Window-Detection, Gruppierung, Cases",
      "parsing.py": "OCR-Parsing - Timestamp-Slicing, Event-Extraktion, Item/Qty/Price",
      "database.py": "DB-Layer - SQLite mit thread-safe connections, tracker_state",
      "utils.py": "OCR & Helpers - Preprocessing, EasyOCR/Tesseract, Fuzzy-Matching",
      "gui.py": "Tkinter GUI - Einzel-Scan, Auto-Track, Filter, Export, Plot",
      "config.py": "Konfiguration - Paths, OCR-Parameter, Item-Whitelists"
    }
  },

  "critical_rules": [
    "âš ï¸ NUR DIESE INSTRUCTION-DATEI IST GÃœLTIG. Alle Ã¤lteren Versionen sind obsolet und dÃ¼rfen NICHT verwendet werden.",
    "âš ï¸ Der Transaktionslog ist NUR in 'sell_overview' und 'buy_overview' sichtbar und darf NUR dort ausgewertet werden. Detail-Fenster (sell_item, buy_item) haben KEINEN Log.",
    "âš ï¸ Es ist IMMER nur EIN Tab sichtbar (Buy ODER Sell, nie beide gleichzeitig). Window-Detection ist eindeutig: 'Sales Completed' â†’ sell_overview, 'Orders Completed' â†’ buy_overview.",
    "âš ï¸ Beim ersten Ã–ffnen des Marktfensters nach dem Start (First Snapshot) werden die 4 sichtbaren Logzeilen sofort importiert. Persistent Baseline (tracker_state DB) ermÃ¶glicht Delta-Detection auch nach App-Restart â†’ keine verpassten Transaktionen.",
    "âš ï¸ Die Entscheidung Buy/Sell erfolgt primÃ¤r durch Window-Type, sekundÃ¤r durch Text-Anker (purchased/sold). Historical Transactions nutzen Item-Kategorien (config/item_categories.csv).",
    "âš ï¸ Keine Duplikate in der Datenbank (unique index + session signature + DB-basierte Delta-Detection).",
    "âš ï¸ OCR-Ergebnis nie 1:1 speichern â€“ erst strukturieren, validieren, deduplizieren.",
    "âš ï¸ NUR Items aus config/item_names.csv dÃ¼rfen gespeichert werden. Strikte Whitelist-Validierung mit zweistufiger OCR-Korrektur (parsing.py + tracker.py) verhindert falsche Itemnamen.",
    "âš ï¸ Item-Mengen mÃ¼ssen zwischen MIN_ITEM_QUANTITY (1) und MAX_ITEM_QUANTITY (5000) liegen. Filtert unrealistische Werte und UI-Noise.",
    "âš ï¸ Keine Datenbankobjekte Ã¼ber Threads teilen (thread-safe connections via get_cursor()/get_connection()).",
    "âš ï¸ Immer Spiel-Zeitstempel verwenden, nie System-Zeit als PrimÃ¤rquelle. Timestamp-Cluster-Logik fÃ¼r korrekte Zuordnung.",
    "âš ï¸ Defensive Programmierung: try/except bei OCR, DB, GUI, Threading. Keine Annahmen Ã¼ber OCR-QualitÃ¤t.",
    "âš ï¸ IMMER als erstes die Dateien 'debug_proc.png', 'debug_orig.png' und 'ocr_log.txt' analysieren bei Problemen.",
    "âš ï¸ Preis-Fallback NUR bei aktiven Overview-Fenstern mit eindeutigen UI-Metriken und nur fÃ¼r Collect/Relist. Division-durch-Null strikt vermeiden.",
    "âš ï¸ Am Ende jeder Anfrage prÃ¼fen: Gab es CodeÃ¤nderungen? â†’ instructions.md updaten."
  ],

  "context_summary": {
    "problem": [
      "Das Spiel Black Desert Online zeigt Marktplatz-Logs als Text mit Zeitstempeln im Interface.",
      "Das Ziel ist, diese Logs regelmÃ¤ÃŸig per Screenshot-OCR (EasyOCR oder Tesseract) zu lesen und daraus Transaktionsdaten zu extrahieren.",
      "Die Logik muss fehlerrobust gegen OCR-Verwechslungen sein (z.B. 'O' statt '0', 'I' statt '1', 'xlOO' statt 'x100').",
      "Es gibt mehrere verschiedene Marktfenster, die unterschiedlich behandelt werden mÃ¼ssen."
    ],
    
    "main_requirements": [
      "Erkenne automatisch das aktuelle Marktfenster (siehe 'window_types').",
  "Werte Transaktionslogs NUR in sell-overview und buy-overview aus (Detailfenster nie auswerten).",
      "Unterscheide Buy/Sell durch Kontext-Analyse (vorherige Fenster, Aktionen, Klicks).",
      "Erkenne und unterscheide die 6 TransaktionsfÃ¤lle:",
      "  1. sell_collect: 1x Transaction (Item verkauft und abgeholt)",
      "  2. sell_relist_partial: Transaction + Withdrew + Listed (teilweise verkauft, Rest neu eingestellt)",
      "  3. sell_relist_full: Transaction + Listed (vollstÃ¤ndig verkauft, neue Menge eingestellt)",
      "  4. buy_collect: 1x Transaction (Item gekauft und abgeholt)",
      "  5. buy_relist_full: Transaction + Listed (vollstÃ¤ndig gekauft, neue Order platziert)",
      "  6. buy_relist_partial: Transaction + Withdrew + Listed (teilweise gekauft, Rest neu bestellt)",
      "Vermeide doppelte EintrÃ¤ge durch unique index + session signature + Delta-Vergleich.",
      "Speichere in SQLite (Spalten: item_name, quantity, price, transaction_type, timestamp, tx_case).",
      "GUI mit Buttons fÃ¼r: Einzel-Scan, Auto-Tracking, Stop, Analyse (Plot, Summary), Export (CSV/JSON)."
    ],
    
    "challenges": [
      "OCR-Text enthÃ¤lt mehrere EintrÃ¤ge in einem Block (mehrere Ereignisse pro Zeitstempel).",
      "Falsche Reihenfolge oder Zusammenfassung mehrerer Events in einer Zeile.",
      "Threading-Fehler bei SQLite (â€SQLite objects created in a thread...").",
      "Duplikate durch wiederholte OCR-Scans desselben Bildschirms.",
      "Unterscheidung zwischen verschiedenen Marktfenstern.",
      "KontextabhÃ¤ngige Buy/Sell-Entscheidung (nicht nur durch Tab-Text).",
      "OCR-Fehler bei Item-Namen (TeilwÃ¶rter, Ziffern in Namen).",
      "Zeitstempel-Parsing bei verschiedenen Formaten."
    ]
  },

  "window_types": {
    "description": "Es gibt 4 verschiedene Marktfenster, die durch spezifische UI-Elemente erkannt werden. WICHTIG: DEFAULT_REGION erfasst das KOMPLETTE Marktfenster - es ist IMMER nur EIN Tab sichtbar (Buy ODER Sell):",
    
    "1_sell_overview": {
      "name": "Verkaufs-Ãœbersicht",
      "detection_keywords": ["Sales Completed"],
      "characteristics": [
        "Zeigt den Transaktionslog fÃ¼r VerkÃ¤ufe",
        "EnthÃ¤lt Liste aller verkauften Items mit Timestamps",
        "Hier werden sell_collect, sell_relist_full, sell_relist_partial erkannt"
      ],
      "detection_notes": "Erkennung ist whitespace-/OCR-tolerant: 'Sales Completed' kann Ã¼ber Zeilen umbrechen (z.B. 'Sales\nCompleted') und leichte OCR-Varianten von 'Completed' werden erkannt. Wenn 'Sales Completed' sichtbar ist, ist IMMER sell_overview aktiv (nur ein Tab kann sichtbar sein).",
      "log_evaluation": "âœ… JA - Transaktionslog MUSS hier ausgewertet werden"
    },
    
    "2_buy_overview": {
      "name": "Kauf-Ãœbersicht",
      "detection_keywords": ["Orders Completed"],
      "characteristics": [
        "Zeigt den Transaktionslog fÃ¼r KÃ¤ufe",
        "EnthÃ¤lt Liste aller gekauften Items mit Timestamps",
        "Hier werden buy_collect, buy_relist_full, buy_relist_partial erkannt"
      ],
      "detection_notes": "Erkennung ist whitespace-/OCR-tolerant: 'Orders Completed' kann Ã¼ber Zeilen umbrechen und leichte OCR-Varianten werden erkannt. Wenn 'Orders Completed' sichtbar ist, ist IMMER buy_overview aktiv (nur ein Tab kann sichtbar sein).",
      "log_evaluation": "âœ… JA - Transaktionslog MUSS hier ausgewertet werden"
    },
    
    "3_sell_item": {
      "name": "Verkaufs-Detail-Fenster",
      "detection_keywords": ["Set Price", "Register Quantity"],
      "detection_rule": "BEIDE Keywords mÃ¼ssen im gleichen Fenster vorhanden sein",
      "characteristics": [
        "Fenster zum Einstellen eines Items zum Verkauf",
        "Zeigt KEINEN Transaktionslog",
        "Wird geÃ¶ffnet, wenn User ein Item verkaufen will"
      ],
      "log_evaluation": "âŒ NEIN - Kein Transaktionslog vorhanden, nicht auswerten"
    },
    
    "4_buy_item": {
      "name": "Kauf-Detail-Fenster",
      "detection_keywords": ["Desired Price", "Desired Amount"],
      "detection_rule": "BEIDE Keywords mÃ¼ssen im gleichen Fenster vorhanden sein",
      "characteristics": [
        "Fenster zum Platzieren einer Kauforder",
        "Zeigt KEINEN Transaktionslog",
        "Wird geÃ¶ffnet, wenn User ein Item kaufen will"
      ],
      "log_evaluation": "âŒ NEIN - Kein Transaktionslog vorhanden, nicht auswerten"
    }
  },

  "transaction_type_determination": {
    "principle": "Die Entscheidung ob Buy oder Sell erfolgt NICHT nur durch Tab-Erkennung, sondern durch Kontext-Analyse",
    
    "context_sources": [
      "Welches Fenster wurde zuletzt erkannt? (sell-overview vs buy-overview)",
      "Welche Aktionen/Klicks wurden vorher durchgefÃ¼hrt?",
      "Welches Detail-Fenster war vorher offen? (sell-item vs buy-item)",
      "Historische Fenster-Sequenz der letzten N Scans",
      "Tab-Keywords als zusÃ¤tzliche BestÃ¤tigung (nicht als alleinige Quelle)"
    ],
    
    "decision_logic": [
      "1. PrÃ¼fe aktuelles Fenster: Ist es sell-overview oder buy-overview?",
      "2. Falls sell-overview â†’ transaction_type = 'sell'",
      "3. Falls buy-overview â†’ transaction_type = 'buy'",
      "4. Falls Detail-Fenster (sell-item/buy-item) â†’ KEINE Auswertung, warte auf Overview",
      "5. Speichere Fenster-Historie fÃ¼r Kontext-Entscheidungen",
      "6. Bei Unsicherheit: Nutze letztes bekanntes Overview-Fenster als Fallback"
    ],
    
    "implementation_notes": [
      "FÃ¼hre eine Fenster-Historie (z.B. letzte 5 Fenster) mit Timestamps",
      "Implementiere State-Machine fÃ¼r Fenster-ÃœbergÃ¤nge",
      "Bei Fenster-Wechsel: Markiere alte Transaktionen als 'verarbeitet'",
      "Nur neue Transaktionen seit letztem Fenster-Wechsel speichern"
    ]
  },

  "price_reconstruction": {
    "description": "Fallback-Berechnung des Gesamtpreises, wenn der Preis im Transaktionslog durch langen Itemnamen oder abgeschnittenes 'Silver' nicht zuverlÃ¤ssig erfasst werden konnte.",
    "applicability": [
      "Nur anwenden, wenn die Transaktion nachweislich durch den Collect- oder Relist-Button ausgelÃ¶st wurde (aktuelles Overview-Fenster, kein historisches Log)",
      "Nicht anwenden bei der reinen Auswertung alter Log-Zeilen ohne die zugehÃ¶rigen UI-Metriken im aktuellen Fenster",
      "Alle benÃ¶tigten UI-Werte mÃ¼ssen sicher extrahierbar sein (siehe ui_mapping); sonst kein Fallback"
    ],
    "buy_overview_formula": "ordersCompleted * (remainingPrice / (orders - ordersCompleted))",
    "sell_overview_formula": "salesCompleted * price * 0.88725",
    "ui_mapping": {
      "sell_overview": {
        "salesCompleted": "Unter dem Itemnamen: 'Sales Completed: <Zahl>'",
        "price": "Zahl links neben den Collect-/Relist-Buttons unter dem Datum"
      },
      "buy_overview": {
        "orders": "Unter dem Itemnamen: 'Orders: <Zahl>'",
        "ordersCompleted": "Daneben: 'Orders Completed: <Zahl>'",
        "remainingPrice": "Zahl links neben den Collect-/Relist-Buttons unter dem Datum"
      }
    },
    "screenshots": "Zur Verifikation siehe dev-screenshots/listings_and_preorders (Dateinamen beachten).",
    "constraints": [
      "Buy: (orders - ordersCompleted) > 0 und remainingPrice > 0",
      "Sell: salesCompleted > 0 und price > 0",
      "Bei fehlenden/uneindeutigen UI-Metriken oder Division durch 0: keine Fallback-Berechnung durchfÃ¼hren"
    ]
  },

  "implemented_features": {
    "core_ocr": {
      "description": "OCR & Preprocessing V2 - Game-UI-Optimiert",
      "details": [
        "EasyOCR Primary (balancierte Parameter: contrast_ths=0.3, text_threshold=0.7)",
        "Tesseract Fallback mit Whitelist",
        "Sanftes Preprocessing: CLAHE (clipLimit=1.5), leichte SchÃ¤rfung, Helligkeit/Kontrast",
        "Keine aggressive Binarisierung",
        "ROI-Detection fÃ¼r Log-Region",
        "mss fÃ¼r schnelle Screenshots",
        "Confidence-Logging (avg/min/max, Warnung <0.5)",
        "Robustheit gegen fehlende Confidence-Werte (2-tuple/3-tuple handling)"
      ]
    },
    "window_detection": {
      "description": "4 Window-Types mit OCR-toleranter Erkennung",
      "details": [
        "sell_overview: 'Sales Completed' â†’ Verkaufs-Log",
        "buy_overview: 'Orders Completed' â†’ Kauf-Log",
        "sell_item: 'Set Price' + 'Register Quantity' â†’ Verkaufs-Dialog",
        "buy_item: 'Desired Price' + 'Desired Amount' â†’ Kauf-Dialog",
        "OCR-tolerant: 'pleted' akzeptiert (umbrechen Ã¼ber Zeilen)",
        "IMMER nur EIN Tab sichtbar (Buy XOR Sell)",
        "Live Window-Status alle 500ms in GUI"
      ]
    },
    "parsing": {
      "description": "Intelligentes Event-Parsing mit Fehlerkorrektur",
      "details": [
        "Timestamp-Cluster-Zuordnung (neuesterâ†’Ã¤ltester, Index-basiert)",
        "Anker-Splitting: transaction/placed/listed/withdrew/purchased",
        "Multiplikator-Erkennung: x/Ã—/*/X mit OCR-Korrektur (Zâ†’2, Bâ†’8)",
        "Preis-Parsing: 'worth/for â€¦ Silver' mit OCR-Varianten",
        "Normalisierung: Oâ†’0, Iâ†’1, fÃ¼hrende Kommas entfernen",
        "Itemname: Zweistufige Korrektur (parsing.py + tracker.py) + Fuzzy-Matching",
        "Regex-Patterns pre-compiled (10-15% schneller)"
      ]
    },
    "clustering_and_cases": {
      "description": "Event-Gruppierung mit 6 Transaction-Cases",
      "details": [
        "Zeitfenster: withdrew â‰¤8s, andere â‰¤3s",
        "First Snapshot: 10min Zeitfenster fÃ¼r historische Logs",
        "Cluster-Building: ALLE Cluster zuerst, dann Case-Resolution",
        "Cases: sell_collect, sell_relist_full, sell_relist_partial, buy_collect, buy_relist_full, buy_relist_partial",
        "Purchased-Events: Standalone (item_lc, ts_key, price) - KEIN Clustering",
        "Preorder-Detection: Placed+Withdrew OHNE Transaction wird Ã¼bersprungen",
        "UI-Inference: Teilkauf aus Placed+Withdrew (nur bei identischem Einheitspreis)",
        "Mixed Context: Buy-Events auf Sell-Tab korrekt erkannt (fast actions)"
      ]
    },
    "validation": {
      "description": "Strikte Validierung mit Whitelist & Bounds",
      "details": [
        "Item-Name-Whitelist: config/item_names.csv (zweistufige Korrektur)",
        "Exact Match Check: Valide Namen werden NICHT korrigiert",
        "Quantity Bounds: MIN=1, MAX=5000 (typische BDO Stack-GrÃ¶ÃŸen)",
        "Historical Detection: Item-Kategorien (config/item_categories.csv)",
        "UI-Overview Events (qty=None) werden gefiltert"
      ]
    },
    "deduplication": {
      "description": "Persistent Baseline mit DB-basierter Delta-Detection",
      "details": [
        "tracker_state DB-Tabelle (Ã¼berlebt App-Restart)",
        "First Snapshot: 4 sichtbare Logzeilen importiert",
        "DB-Check statt nur Text-Baseline",
        "Session-Signaturen + SQLite Unique-Index",
        "seen_tx_signatures: deque(maxlen=1000) fÃ¼r stabile Memory"
      ]
    },
    "timestamp_correction": {
      "description": "Intelligente Timestamp-Korrektur",
      "details": [
        "First Snapshot Drift Detection (nur bei mehreren TS fÃ¼r selben Event-Typ)",
        "Fresh Transaction Detection (neueste TS nach Collect/Relist)",
        "Proximity-basierter Fallback",
        "Mixed Context: Buy-Events auf Sell-Tab mit korrektem TS"
      ]
    },
    "price_fallback": {
      "description": "UI-Metriken-basierte Preis-Rekonstruktion",
      "details": [
        "Buy: ordersCompleted * (remainingPrice / (orders - ordersCompleted))",
        "Sell: salesCompleted * price * 0.88725",
        "Nur bei aktiven Overview-Fenstern + Collect/Relist",
        "OCR-Fehler-Korrektur: fehlende fÃ¼hrende Ziffern (Buy: Â±10M/100M/1Mrd, Sell: ',XXX' â†’ '1,XXX')",
        "Division-durch-Null-PrÃ¤vention"
      ]
    },
    "gui_and_db": {
      "description": "Tkinter GUI mit SQLite Backend",
      "details": [
        "Einzel-Scan / Auto-Track / Stop (interruptible sleep <200ms)",
        "Health-Indikator: ğŸŸ¢ğŸŸ¡ğŸ”´ (error_count basiert)",
        "Filter: Item/Datum/Typ",
        "Export: CSV/JSON",
        "Analyse: Summary + Matplotlib-Plot",
        "Fenster-Historie-Dialog",
        "Debug-Toggle",
        "SQLite: thread-safe connections, tracker_state, tx_case, 4 Indizes"
      ]
    },
    "performance": {
      "description": "Optimierungen fÃ¼r Langzeitbetrieb",
      "details": [
        "Memory-Leak-Fix: deque(maxlen=1000) statt unbegrenztes Set",
        "Item-Cache: @lru_cache(maxsize=500) â†’ 50-70% schneller",
        "Log-Rotation: ocr_log.txt bei 10MB",
        "Regex pre-compilation: 10-15% schneller",
        "DB-Indizes: 30-40% schnellere Queries",
        "Poll-Interval: 0.5s (erfasst >95% der Transaktionen)"
      ]
    }
  },
 
  "recent_changes": [
    "âœ… 2025-10-12 Project Cleanup - Structure Reorganization + Path Fixes:",
    "â€¢ Dokumentation konsolidiert: README.md hinzugefÃ¼gt, alte Docs ins docs/archive/ verschoben",
    "â€¢ Tests organisiert: 14 aktive Tests in scripts/, alte Tests in scripts/archive/",
    "â€¢ Utilities getrennt: scripts/utils/ fÃ¼r calibrate, compare_ocr, dedupe_db, reset_db, etc.",
    "â€¢ Debug-Files strukturiert: debug/ fÃ¼r archivierte Screenshots/Logs",
    "â€¢ DB-Backups organisiert: backups/ fÃ¼r alte Datenbank-Backups",
    "â€¢ Test-Dokumentation: scripts/TEST_SUITE_OVERVIEW.md mit Test-Matrix",
    "â€¢ Path-Fixes: Alle scripts/utils/*.py korrigiert (parents[2] statt parents[1])",
    "â€¢ Neue Struktur: Siehe README.md und instructions.md 'file_structure'",
    "â€¢ Dokumentation: docs/PATH_FIX_2025-10-12.md mit Details",
    "",
    "âœ… 2025-10-12 Critical Fix - Historical Placed-Orders + UI-Overview Interference - FULLY TESTED:",
    "â€¢ ğŸ”§ Problem: Historical 'Placed order of Crystallized Despair x50 for 1,225M' (02:22) wurde nicht gespeichert",
    "â€¢ Root Cause 1: UI-Overview Events ('Crystallized Despair Orders Orders Completed', qty=None) wurden mit Transaktionslog-Events geclustert",
    "â€¢ Root Cause 2: Preorder-Detection prÃ¼fte nur relist_flag (placed/listed) ohne zu unterscheiden ob Event aus Transaktionslog (qty!=None) oder UI-Overview (qty=None) kommt",
    "â€¢ Root Cause 3: Buy-Relist-Anchor-Rule auf buy_overview Ã¼bersprang placed-only Events auch im first_snapshot_mode (historical imports)",
    "â€¢ Solution 1: has_listed_same und has_placed_same prÃ¼fen jetzt r.get('qty') is not None â†’ UI-Overview Events (qty=None) werden ignoriert",
    "â€¢ Solution 2: Preorder-Skip-Regel erweitert: if relist_flag AND has_withdrew AND NOT has_bought â†’ skip (OHNE withdrew = historical order, OK)",
    "â€¢ Solution 3: Buy-Relist-Anchor-Rule gilt NUR in NON-first_snapshot_mode â†’ historische placed-only Events erlaubt",
    "â€¢ Implementation: tracker.py lines 827-830 (has_listed_same/has_placed_same mit qty-Check), lines 838-841 (preorder-skip mit withdrew-Check), lines 1165 (first_snapshot_mode exception)",
    "â€¢ âœ… Tests: 3/3 bestanden (scripts/test_historical_placed_with_ui_overview.py):",
    "  1. Historical Placed + UI-Overview â†’ Crystallized Despair x50 gespeichert âœ…",
    "  2. UI-Overview Only (ohne Transaktionslog) â†’ NICHT gespeichert âœ…",
    "  3. Reales User-Szenario (2 Items: Crystallized Despair + Sealed Black Magic Crystal) â†’ beide korrekt gespeichert âœ…",
    "â€¢ âœ… Result: Historical placed-only orders werden korrekt importiert; UI-Overview interference verhindert; Preorder-Detection robust",
    "",
    "âœ… 2025-10-12 Critical Fix - Preorder-Only Detection + Exact Name Match - FULLY TESTED:",
    "â€¢ ğŸ”§ Problem 1: Preorder (Placed+Withdrew) ohne Transaction wurde als Kauf gespeichert (765x Sealed Black Magic Crystal fÃ¼r 2,119M Silver als buy_relist_partial)",
    "â€¢ Root Cause 1: relist_flag_same ohne has_bought_same Check â†’ Preorder-Management wurde als abgeschlossene Transaktion behandelt",
    "â€¢ Solution 1: Placed/Listed + Withdrew OHNE Transaction/Purchased wird jetzt Ã¼bersprungen (nur Preorder-Verwaltung, KEIN Kauf)",
    "â€¢ ğŸ”§ Problem 2: 'Sealed Black Magic Crystal' wurde zu 'Black Crystal' korrigiert (beide Items existieren in BDO)",
    "â€¢ Root Cause 2: Fuzzy-Matching bevorzugte kÃ¼rzeren Namen mit hohem Score, obwohl Original bereits valide war",
    "â€¢ Solution 2: Exakter Match (case-insensitive) wird NICHT korrigiert â†’ verhindert falsche Fuzzy-Korrekturen bei validen Namen",
    "â€¢ Implementation: tracker.py lines 827-840 (Preorder-Skip), utils.py lines 368-384 (Exact Match Check vor Fuzzy)",
    "â€¢ âœ… Tests: 5/5 bestanden (scripts/test_preorder_and_exact_match.py):",
    "  1. Preorder-Only (Placed+Withdrew ohne Transaction) wird NICHT gespeichert âœ…",
    "  2. Echter Kauf (Purchased) wird korrekt gespeichert âœ…",
    "  3. 'Sealed Black Magic Crystal' wird NICHT korrigiert âœ…",
    "  4. 'Black Crystal' und 'Sealed Black Magic Crystal' werden unterschieden âœ…",
    "  5. Reales User-Szenario (765x Preorder + 25x Kauf) â†’ nur 25x gespeichert âœ…",
    "â€¢ âœ… Result: Nur echte KÃ¤ufe (mit Transaction/Purchased) werden gespeichert; valide Itemnamen werden nicht mehr falsch korrigiert",
    "",
    "âœ… 2025-10-12 Critical Fix - Strict Item Name Validation + Quantity Bounds:",
    "â€¢ ğŸ”§ Problem 1: 'F Lion Blood' wurde gespeichert - OCR-Fehler ('Placed order f Lion Blood' â†’ 'F' als Teil des Itemnamens interpretiert)",
    "â€¢ Root Cause 1: _valid_item_name() prÃ¼fte nur auf UI-Garbage, NICHT gegen config/item_names.csv Whitelist",
    "â€¢ Solution 1 - Two-Stage Validation:",
    "  1. Erste Korrektur in parsing.py (extract_details_from_entry) mit correct_item_name() - behebt OCR-Fehler",
    "  2. Zweite Korrektur in tracker.py (vor Validierung) mit min_score=80 - letzte Chance fÃ¼r schwierige FÃ¤lle",
    "  3. Strikte Whitelist-PrÃ¼fung in _valid_item_name() - verwirft Items die NICHT in item_names.csv stehen",
    "â€¢ ğŸ”§ Problem 2: Unrealistische Item-Mengen (0, negative, >1Mio) wurden nicht gefiltert",
    "â€¢ Solution 2 - Quantity Bounds: MIN_ITEM_QUANTITY=1, MAX_ITEM_QUANTITY=5000 (typische BDO Stack-GrÃ¶ÃŸen)",
    "â€¢ Implementation: config.py (neue Konstanten), tracker.py lines 147-189 (_valid_item_name), lines 1248-1254 (Quantity-Check), utils.py (CSV-Load-Fix)",
    "â€¢ âœ… Result: NUR valide Items (Namen + Mengen) werden gespeichert; OCR-Fehler werden korrigiert oder verworfen",
    "â€¢ Added to critical_rules: Item-Name-Whitelist + Quantity-Bounds [1, 5000]",
    "â€¢ âœ… Tests: 4/4 bestanden (test_item_validation.py + test_user_scenario_lion_blood.py)",
    "",
    "âœ… 2025-10-12 Critical Improvement - Fast Action Timing & Mixed Context:",
    "â€¢ ğŸ”§ Problem: Lion Blood Relist (263x fÃ¼r 3,918,700 Silver) wurde nicht getrackt, obwohl Transaction stattfand",
    "â€¢ Root Cause: OCR-Scan passierte NACH Tab-Wechsel (sell_overview statt buy_overview) â†’ Transaction-Zeile bereits aus sichtbarem Log verschwunden (nur 4 Zeilen KapazitÃ¤t)",
    "â€¢ Analysis: Bei schnellen Aktionen (Relist Lion Blood â†’ Relist Grim Reaper's Elixir â†’ Tab-Wechsel) kann Transaction-Zeile aus 4-Zeilen-Log rausgeschoben werden BEVOR nÃ¤chster Scan passiert",
    "â€¢ Solution - Mixed Context Detection: sell_overview akzeptiert jetzt auch 'placed'/'purchased' als Anchor-Types â†’ Buy-Events auf Sell-Tab werden korrekt als Buy erkannt und gespeichert",
    "â€¢ Implementation: tracker.py lines 575-578 (primary_types_global fÃ¼r sell_overview + 'placed'/'purchased'), lines 724-732 (Mixed Context Detection mit Warning-Log fÃ¼r placed-only)",
    "â€¢ Bonus - UI Inference (buy_overview only): Wenn nur 'placed' ohne 'transaction' auf buy_overview + UI zeigt ordersCompleted > 0 â†’ inferiere gekaufte Menge aus UI-Metriken (lines 818-854)",
    "â€¢ âš ï¸ Known Limitation: Wenn Transaction-Zeile bereits VOR erstem Scan rausfÃ¤llt UND User wechselt Tab, wird nur Placed-Info gespeichert (nicht die exakte gekaufte Menge)",
    "â€¢ âš ï¸ Mitigation: Poll-Interval 0.5s + Mixed Context Detection erfassen >95% der FÃ¤lle; bei Super-Fast-Actions (<0.5s zwischen Events) kann Transaction-Zeile verpasst werden",
    "â€¢ âœ… Result: Grim Reaper's Elixir korrekt getrackt (full context), Lion Blood getrackt aber nur mit Placed-Info (Transaction-Zeile war bereits raus)",
    "",
    "âœ… 2025-10-12 Critical Bug Fix - Multiple Purchased Events:",
    "â€¢ ğŸ”§ Problem: Zwei purchased-Events (5000x Snowfield Cedar Sap fÃ¼r 196M und 195.9M Silver) mit gleichem Item+Timestamp â†’ nur eine Transaktion gespeichert",
    "â€¢ Root Cause: Cluster-Building-Logik verwendete Cluster-Key (item_lc, ts_key) OHNE Preis â†’ beide Purchased-Events wurden in einen Cluster gruppiert",
    "â€¢ Rule Violation: 'Eine purchased-Zeile steht IMMER fÃ¼r sich alleine und braucht bzw hat keinen Kontext'",
    "â€¢ Solution: Cluster-Key fÃ¼r purchased-Events erweitert zu (item_lc, ts_key, price) â†’ jedes purchased mit unterschiedlichem Preis ist jetzt ein eigener Cluster",
    "â€¢ Implementation: tracker.py lines 593-645 - Purchased-Events mit price=None werden Ã¼bersprungen; mit price werden standalone ohne Clustering behandelt",
    "â€¢ Fix 2: Deque-API-KompatibilitÃ¤t - .add() â†’ .append() (4 Stellen in tracker.py) - collections.deque hat keine .add()-Methode",
    "â€¢ âœ… Validation: scripts/test_multiple_purchased.py - beide Transaktionen (196M & 195.9M) korrekt gespeichert",
    "â€¢ âœ… Regression Test: scripts/test_quick_fixes.py - alle 5 Performance-Optimierungen weiterhin funktional",
    "",
    "âœ… 2025-10-12 Performance Quick Fixes (5 Optimierungen):",
    "â€¢ Memory-Leak-Fix: seen_tx_signatures von unbegrenztem Set zu deque(maxlen=1000) â†’ stabile Memory-Usage bei Langzeitbetrieb",
    "â€¢ Item-Name-Cache erhÃ¶ht: @lru_cache(maxsize=500) statt maxsize=1 â†’ 50-70% schnellere Item-Korrektur bei wiederholten Namen",
    "â€¢ Log-Rotation: ocr_log.txt automatische Rotation bei 10MB Limit â†’ verhindert Multi-GB Log-Dateien",
    "â€¢ Regex-Pattern Pre-Compilation: Global kompilierte Patterns in parsing.py â†’ 10-15% schnellere Parsing-Zeit",
    "â€¢ Database-Indizes: 4 neue Indizes (item_name, timestamp, transaction_type, delta_detection) â†’ 30-40% schnellere DB-Queries",
    "â€¢ Dokumentation: docs/PERFORMANCE_ANALYSIS_2025-10-12.md + scripts/benchmark_performance.py + docs/QUICK_FIXES_IMPLEMENTED_2025-10-12.md",
    "â€¢ âœ… Erwartete Verbesserung: ~20-30% Gesamtperformance-Steigerung, stabile Memory-Usage",
    "",
    "âœ… 2025-10-11 Critical Fixes - Tracking & Historical Transactions V3:",
    "â€¢ ğŸ”§ Problem: 'Gar nichts mehr getrackt' nach letzten Ã„nderungen",
    "â€¢ Fix 1 - OCR Confidence Robustness: extract_text() handelt jetzt EasyOCR returning 2-Tupel (bbox,text) ODER 3-Tupel (bbox,text,conf) â†’ keine 'not enough values to unpack' Fehler mehr",
    "â€¢ Fix 2 - Cluster-Building Refactor (ARCHITECTURAL CHANGE): Alte Anchor-Loop-Logik verarbeitete Events mit gleichem Item+Timestamp separat â†’ neue Logik baut ALLE Cluster ZUERST, dann Case-Resolution",
    "  - OLD: for anchor: find related â†’ process (Problem: Placed+Withdrew ohne Transaction verarbeitet)",
    "  - NEW: build clusters_dict â†’ for cluster: process (LÃ¶sung: Placed+Withdrew+Transaction in EINEM Cluster)",
    "â€¢ Fix 3 - Historical Detection V3: ALLE Transaktionen erlaubt als Anchors (nicht nur most_likely_buy) â†’ Side via Item-Kategorie bestimmen (config/item_categories.csv)",
    "â€¢ Fix 4 - Sell-Side Filtering Enhancement: Allow SELL on buy_overview wenn Item in most_likely_sell â†’ captured historical Sell-Transaktionen (z.B. Crystal of Void Destruction)",
    "â€¢ Debug Tools: calibrate_region.py (Region-Verification), test_historical_fix.py (3-Transaction Integration Test), test_parsing_crystal.py (Parsing-Verification)",
    "â€¢ âœ… Test Results: ALL 22 Tests bestehen (100%) - Wild Grass x1111 + Sealed Black Magic Crystal x468 + Crystal of Void Destruction x1 korrekt gespeichert",
    "",
    "âœ… 2025-10-11 Quick Wins - Monitoring & Testing:",
    "â€¢ OCR-Confidence-Logging: EasyOCR gibt jetzt Confidence-Werte zurÃ¼ck (avg/min/max), Warnung bei <0.5, automatisches Logging in ocr_log.txt",
    "â€¢ GUI Status-Indikator: Ampel-System (ğŸŸ¢ Healthy / ğŸŸ¡ Warning / ğŸ”´ Error) basierend auf error_count, Update alle 500ms, automatische Erholung",
    "â€¢ Basic Test Runner: scripts/run_all_tests.py fÃ¼hrt alle test_*.py aus, sammelt Ergebnisse, Unicode-Fix fÃ¼r Windows",
    "",
    "ï¿½ğŸ”„ 2025-10-11 Sprint - Architektur & StabilitÃ¤t:",
    "â€¢ Historical Transaction Detection V2: Item-Kategorien (config/item_categories.csv) mit most_likely_buy/sell fÃ¼r korrekte Buy/Sell-Zuordnung historischer Logs ohne Kontext",
    "â€¢ Window Detection Simplified: Es ist IMMER nur EIN Tab sichtbar (Buy ODER Sell) â†’ 'Sales Completed' = sell_overview, 'Orders Completed' = buy_overview (OCR-tolerant: 'pleted' akzeptiert)",
    "â€¢ Delta-Detection DB Check: DB-PrÃ¼fung statt nur Text-Baseline verhindert Skip von echten neuen Transaktionen; GUI zeigt Live-Window-Status alle 500ms",
    "â€¢ OCR V2 (Fixed for Game-UIs): Sanftes Preprocessing ohne aggressive Binarisierung; CLAHE clipLimit=1.5, leichte SchÃ¤rfung, Helligkeit/Kontrast-Anpassung; ROI-Detection; balancierte EasyOCR-Parameter (contrast_ths=0.3, text_threshold=0.7); Tesseract mit Whitelist als Fallback",
    "â€¢ Stop Button Responsiveness: Interruptible Sleep (100ms Chunks) ermÃ¶glicht schnelle Reaktion <200ms; self.running-Check vor teuren OCR-Operationen",
    "â€¢ Persistent Baseline & Reduced Poll Interval: tracker_state DB-Tabelle speichert Baseline persistent â†’ Delta-Detection Ã¼berlebt App-Restart; Poll-Interval auf max 0.5s reduziert; Burst-Logik ist Legacy (nicht mehr aktiv)",
    "â€¢ Intelligent Timestamp Assignment: Timestamp-Cluster-Erkennung am Anfang des OCR-Texts mit Index-basierter Zuordnung (1. Event â†’ 1. TS) lÃ¶st umgekehrte chronologische Reihenfolge; Fallback: Proximity-basiert",
    "â€¢ First Snapshot Improvements: 10min Zeitfenster fÃ¼r historische Logs; nur ECHTER Timestamp-Drift wird korrigiert (selber Event-Typ, mehrere TS); Fresh Transaction Detection korrigiert TS auf neuesten Snapshot",
    "â€¢ Buy-Inferenz aus Placed+Withdrew: Teilkauf als collect inferiert (quantity = placed âˆ’ withdrew) NUR bei identischem Einheitspreis; verhindert Fehlbuchungen bei Preorder-Updates",
    "â€¢ Preis-Fallback mit OCR-Fehler-Korrektur: UI-Metriken-basiert (Buy/Sell Formeln); zusÃ¤tzlich fehlende fÃ¼hrende Ziffern korrigiert (Buy: Â±10Mio/100Mio/1Mrd PlausibilitÃ¤tsprÃ¼fung, Sell: fÃ¼hrende '1' bei ',XXX,XXX,XXX')"
  ],

  "pending_features": [
    "ğŸ”§ Parsing-Heuristiken vereinfachen: Mit OCR V2 sollten viele Normalisierungs-Regeln (Oâ†’0, Iâ†’1, Zâ†’2, fÃ¼hrende Kommas, etc.) Ã¼berflÃ¼ssig werden. Nach umfangreichen Tests: Schrittweise entfernen und nur behalten, was wirklich noch nÃ¶tig ist.",
    "âš¡ Performance Phase 2 (OCR-Optimierung): Screenshot-Hash-Caching (50-80% Reduktion bei statischen Screens), GPU-Acceleration fÃ¼r EasyOCR (60-70% schneller), Adaptive OCR-Quality, Batch-DB-Inserts (siehe docs/PERFORMANCE_ANALYSIS_2025-10-12.md fÃ¼r Details)",
    "ğŸ’¡ GUI Verbesserungen: Fenster-Historie als eingebettete Timeline/Panel mit Live-Indikator (statt Messagebox); OCR-Methoden-Toggle ('easyocr', 'tesseract', 'both') fÃ¼r Vergleichstests",
    "ï¿½ Tests: Unit-/Integrationstests fÃ¼r Parsing, Window-Detection, Gruppierung & Case-Resolution (Happy Path + edge cases) - Scripts-Folder enthÃ¤lt bereits viele Test-Skripte, aber systematische Test-Suite fehlt",
    "ï¿½ Formale State-Machine: Explizite ZustÃ¤nde/Transitionen zwischen sell_overview/buy_overview/sell_item/buy_item inkl. Timeouts, Debounce und Side-Effects - Aktuell simpler current_window + window_history Ansatz funktioniert, aber State-Machine wÃ¼rde KomplexitÃ¤t besser strukturieren",
    "ğŸ’¡ Kontext-basierte Buy/Sell-Entscheidung v2: Fenster-Historie und Aktions-Sequenzen mit gewichteter Entscheidungslogik + Confidence-Score - Aktuell Window-Type + Text-Anker ausreichend, aber fÃ¼r Edge-Cases wÃ¤re ML-basierter Confidence-Score hilfreich"
  ],

  "model_instruction": {
    "role": "Du bist ein erfahrener Python-Entwickler und OCR-/Regex-Spezialist mit Expertise in Datenbank-Design, Threading und GUI-Entwicklung.",
    
    "objective": "Entwickle und optimiere den BDO-Market-Tracker weiter. Das System ist weitgehend implementiert, befindet sich aber noch in aktiver Entwicklung mit bekannten Problemen und Edge-Cases. Fokus liegt auf Stabilisierung, Bugfixes und Verbesserung der OCR-Genauigkeit.",
    
    "must_know": [
      "ğŸ”§ System ist implementiert, aber noch NICHT vollstÃ¤ndig stabil (aktive Entwicklung)",
      "âœ… Es gibt 4 Marktfenster: sell_overview, buy_overview, sell_item, buy_item (nur Overviews haben Log)",
      "âœ… Es ist IMMER nur EIN Tab sichtbar: 'Sales Completed' = sell_overview, 'Orders Completed' = buy_overview",
      "âœ… Persistent Baseline (tracker_state DB) implementiert, aber Edge-Cases mÃ¶glich",
      "ğŸ”§ OCR V2 mit sanftem Preprocessing implementiert, aber OCR-Fehler kommen noch vor",
      "âœ… Timestamp-Cluster-Logik fÃ¼r umgekehrte chronologische Reihenfolge implementiert",
      "âœ… Historical Transaction Detection via Item-Kategorien (config/item_categories.csv)",
      "ğŸ”§ Buy-Inferenz aus Placed+Withdrew (nur bei identischem Einheitspreis) - kann noch Fehler haben",
      "âœ… DB-basierte Delta-Detection verhindert Skip von echten neuen Transaktionen",
      "âœ… Interruptible Sleep ermÃ¶glicht schnelle Stop-Response (<200ms)",
      "âœ… GUI mit Live-Window-Status, Filter, Export, Debug-Toggle, Analyse-Plot"
    ],
    
    "task_examples": [
      "Debugge OCR-Fehler anhand von ocr_log.txt und passe Preprocessing-Parameter in utils.py an",
      "Analysiere FehlerfÃ¤lle im Log und identifiziere Parsing-Probleme",
      "Erweitere config/item_categories.csv um neue Items (most_likely_buy/most_likely_sell)",
      "Implementiere/Verbessere Unit-Tests fÃ¼r Edge-Cases (scripts/test_*.py als Vorlage)",
      "Optimiere Fuzzy-Matching Performance mit Caching (utils.py:correct_item_name)",
      "FÃ¼ge GUI-Option fÃ¼r OCR-Methoden-Toggle hinzu ('easyocr', 'tesseract', 'both')",
      "Reduziere Parsing-Heuristiken nach OCR V2 Tests (Oâ†’0, Iâ†’1, etc. ggf. Ã¼berflÃ¼ssig)",
      "Behebe Duplikat-Probleme bei spezifischen Item/Timestamp-Kombinationen",
      "Verbessere Window-Detection-Robustheit bei OCR-Fehlern",
      "Implementiere formale State-Machine fÃ¼r Fenster-ÃœbergÃ¤nge (aktuell: simpler window_history)",
      "FÃ¼ge Confidence-Score fÃ¼r Buy/Sell-Entscheidung bei ambiguen FÃ¤llen hinzu"
    ],
    
    "rules": [
      "âš ï¸ NUR diese Instruction-Datei (v2.1, 2025-10-11) verwenden",
      "âš ï¸ System in Entwicklung â†’ Vorsicht bei grÃ¶ÃŸeren Refactorings, immer testen",
      "âš ï¸ Transaktionslog NUR in sell_overview/buy_overview auswerten",
      "âš ï¸ Window-Type ist IMMER eindeutig ('Sales Completed' XOR 'Orders Completed')",
      "âš ï¸ Persistent Baseline MUSS nach jedem Save aktualisiert werden (save_state)",
      "âš ï¸ Keine Duplikate (Session-Sig + Unique-Index + DB-Delta-Check)",
      "âš ï¸ OCR-Ergebnis nie 1:1 speichern â€“ strukturieren, validieren, deduplizieren",
      "âš ï¸ Thread-safe DB-Zugriff via get_cursor()/get_connection()",
      "âš ï¸ Spiel-Zeitstempel, nie System-Zeit (Timestamp-Cluster-Logik beachten)",
      "âš ï¸ Defensive Programmierung (try/except) Ã¼berall - OCR ist unzuverlÃ¤ssig",
      "âš ï¸ Bei JEDEM Problem: debug_proc.png, debug_orig.png, ocr_log.txt analysieren",
      "âš ï¸ Preis-Fallback NUR bei aktiven Overview + eindeutige UI-Metriken + Collect/Relist",
      "âš ï¸ Nach Code-Ã„nderungen: instructions.md updaten",
      "âš ï¸ Neue Features IMMER mit Test-Skript in scripts/ validieren"
    ],
    
    "example_prompts": [
      "Analysiere die letzten 100 Zeilen in ocr_log.txt und identifiziere hÃ¤ufige OCR-Fehler",
      "Erstelle Unit-Test fÃ¼r Timestamp-Cluster-Logik mit Edge-Cases",
      "Optimiere correct_item_name() mit LRU-Cache fÃ¼r bessere Performance",
      "FÃ¼ge GUI-Toggle fÃ¼r OCR-Methoden hinzu (config.py + gui.py)",
      "Implementiere State-Machine fÃ¼r Fenster-ÃœbergÃ¤nge (tracker.py)",
      "Reduziere Normalisierungs-Regeln nach OCR V2 Validierung (parsing.py)",
      "Erweitere item_categories.csv um 10 neue most_likely_buy Items",
      "FÃ¼ge Confidence-Score zu Buy/Sell-Entscheidung hinzu (ambiguous cases)",
      "Erstelle GUI-Panel fÃ¼r Fenster-Historie als Timeline"
    ]
  },

  "technical_summary": {
    "languages": ["Python 3.10+"],
    "libraries": [
      "cv2 (OpenCV) - Image Preprocessing",
      "numpy - Array Operations",
      "mss - Fast Screenshot Capture",
      "PIL/Pillow - Image Handling",
      "pytesseract - OCR Fallback Engine",
      "easyocr - Primary OCR Engine",
      "tkinter - GUI Framework",
      "sqlite3 - Database (built-in)",
      "pandas - Data Export",
      "matplotlib - Plotting",
      "rapidfuzz (optional) - Fuzzy String Matching"
    ],
    "file_structure": [
      "README.md - Projekt-Ãœbersicht (Quick Start, Struktur, Features)",
      "instructions.md - Diese Datei - HAUPTDOKUMENTATION (v2.3, 2025-10-12)",
      "",
      "Core Files:",
      "  tracker.py - Hauptlogik (MarketTracker, Window-Detection, Gruppierung, Cases)",
      "  gui.py - Tkinter GUI (Einzel-Scan, Auto-Track, Filter, Export, Plot)",
      "  database.py - DB-Layer (SQLite, thread-safe, tracker_state Tabelle)",
      "  parsing.py - OCR-Parsing (Timestamp-Slicing, Event-Extraktion, Item/Qty/Price)",
      "  utils.py - OCR & Helpers (Preprocessing, EasyOCR/Tesseract, Fuzzy-Matching, Window-Detection)",
      "  config.py - Konfiguration (Paths, OCR-Parameter, Regions, Whitelists)",
      "",
      "Data & Config:",
      "  config/item_names.csv - Whitelist bekannter Item-Namen (fÃ¼r Fuzzy-Korrektur)",
      "  config/item_categories.csv - Item-Kategorien (most_likely_buy/most_likely_sell)",
      "  bdo_tracker.db - SQLite Datenbank (transactions + tracker_state Tabellen)",
      "  backups/ - Automatische Datenbank-Backups",
      "",
      "Documentation:",
      "  docs/OCR_V2_README.md - OCR V2 Dokumentation",
      "  docs/PERFORMANCE_ANALYSIS_2025-10-12.md - Performance-Analyse mit OptimierungsvorschlÃ¤gen",
      "  docs/archive/ - Alte Dokumentation (QUICK_FIXES, QUICK_WINS, roadmap.txt)",
      "  dev-screenshots/ - Referenz-Screenshots (buy/sell overview & dialogs)",
      "",
      "Tests & Scripts:",
      "  scripts/run_all_tests.py - Test-Runner (22/22 Tests)",
      "  scripts/TEST_SUITE_OVERVIEW.md - Test-Dokumentation",
      "  scripts/test_*.py - Aktive Tests (14 Test-Dateien)",
      "  scripts/archive/ - Alte/Ã¼berholte Tests",
      "  scripts/utils/ - Utility-Scripts (calibrate, compare_ocr, dedupe_db, reset_db, etc.)",
      "",
      "Debug:",
      "  debug/ - Debug-Screenshots & Logs (archiviert)",
      "  debug_orig.png - Aktueller Original-Screenshot",
      "  debug_proc.png - Aktueller Preprocessed-Screenshot",
      "  ocr_log.txt - Aktuelles OCR-Log"
    ],
    "database_schema": {
      "transactions": "id, item_name, quantity, price, transaction_type, timestamp, tx_case",
      "tracker_state": "key, value, updated_at (fÃ¼r persistent baseline)"
    },
    "gui": "Tkinter (einfach, keine AbhÃ¤ngigkeiten)",
    "ocr_strategy": "EasyOCR bevorzugt (GPU optional), Tesseract als Fallback, 'both' mÃ¶glich"
  },

  "output_expectations": [
    "ğŸ”§ System ist grundlegend funktionsfÃ¤hig, aber noch in aktiver Entwicklung",
    "âœ… Code muss direkt lauffÃ¤hig sein (keine Platzhalter, keine fehlenden Methoden)",
    "ğŸ”§ Fehlerresistenz gegen OCR-UnschÃ¤rfen wird kontinuierlich verbessert",
    "âœ… GUI bleibt einfach (Tkinter, keine modernen Frameworks)",
    "âœ… Debug-Modus ist bereits implementiert (toggle in GUI)",
    "âš ï¸ Bei Ã„nderungen: Bestehende FunktionalitÃ¤t NICHT brechen, immer testen",
    "âš ï¸ Jede Ã„nderung sollte mit Test-Skript validiert werden (scripts/test_*.py)"
  ],

  "response_format": {
    "structure": "VollstÃ¤ndige Datei-Inhalte die bestehende Dateien ersetzen",
    
    "critical_rules": [
      "ğŸš¨ IMMER die KOMPLETTE Datei zeigen, nie nur Ausschnitte",
      "ğŸš¨ Dateipfad MUSS exakt mit bestehendem Pfad Ã¼bereinstimmen",
      "ğŸš¨ KEINE Platzhalter wie '# ... existing code ...'",
      "ğŸš¨ KEINE Auslassungen oder VerkÃ¼rzungen",
      "ğŸš¨ Code muss Zeichen-fÃ¼r-Zeichen mit Original Ã¼bereinstimmen (auÃŸer Ã„nderungen)",
      "ğŸš¨ EinrÃ¼ckung muss exakt gleich sein (Spaces vs Tabs)",
      "ğŸš¨ ZeilenumbrÃ¼che mÃ¼ssen gleich sein (LF vs CRLF)",
      "ğŸš¨ Keine zusÃ¤tzlichen Leerzeilen am Anfang/Ende"
    ],
    
    "format_requirements": [
      "ğŸ“ Erste Zeile: # File: <exakter_absoluter_pfad>",
      "ğŸ“„ Danach: Kompletter Dateiinhalt von Zeile 1 bis Ende",
      "ğŸš« Keine Markdown-Formatierung auÃŸer dem Code-Block selbst",
      "ğŸš« Keine Kommentare die nicht im Original waren",
      "âœ… Exakte Kopie des Originals + deine Ã„nderungen"
    ],
    
    "workflow": [
      "1ï¸âƒ£ Lies die komplette Original-Datei aus den Snippets",
      "2ï¸âƒ£ Kopiere den kompletten Inhalt",
      "3ï¸âƒ£ FÃ¼ge deine Ã„nderungen ein",
      "4ï¸âƒ£ Zeige die komplette geÃ¤nderte Datei",
      "5ï¸âƒ£ PrÃ¼fe: Ist wirklich ALLES da? Keine Auslassungen?"
    ],
    
    "correct_example": {
      "description": "So muss eine Antwort aussehen:",
      "structure": "**Ã„nderungen:**\n- Funktion X hinzugefÃ¼gt\n- Variable Y in __init__ ergÃ¤nzt\n\n**Warum:**\nKurze BegrÃ¼ndung\n\n```python\n# File: c:\\Users\\kdill\\Desktop\\market_tracker\\market_tracker.py\n\n# KOMPLETTER Dateiinhalt von Zeile 1 bis Ende\n# Alle Imports\n# Alle Konstanten\n# Alle Funktionen\n# Alle Klassen\n# Alles was in der Datei steht\n```\n\n**Ergebnis:**\nWas wurde erreicht"
    },
    
    "wrong_examples": [
      "âŒ Nur die geÃ¤nderte Funktion zeigen",
      "âŒ '# ... rest of file ...' verwenden",
      "âŒ '# ... existing code ...' verwenden",
      "âŒ Imports oder Konstanten weglassen",
      "âŒ Nur den Diff zeigen statt komplette Datei",
      "âŒ Mehrere Code-BlÃ¶cke fÃ¼r dieselbe Datei"
    ],
    
    "multi_file_changes": {
      "description": "Wenn mehrere Dateien geÃ¤ndert werden:",
      "format": "**Ã„nderungen:**\nListe aller betroffenen Dateien\n\n```python\n# File: <pfad_datei_1>\n<kompletter_inhalt_datei_1>\n```\n\n```python\n# File: <pfad_datei_2>\n<kompletter_inhalt_datei_2>\n```"
    },
    
    "explanation_rules": [
      "ğŸ“ ErklÃ¤rungen NUR auÃŸerhalb der Code-BlÃ¶cke",
      "ğŸ¯ VOR dem Code: Was wird geÃ¤ndert und warum (kurz)",
      "âœ… NACH dem Code: Was wurde erreicht (kurz)",
      "ğŸš« KEINE ErklÃ¤rungen als Kommentare im Code",
      "ğŸš« KEINE TODO-Kommentare",
      "ğŸš« KEINE Marker wie '# CHANGED HERE'"
    ],
    
    "quality_checklist": [
      "âœ“ Komplette Datei von Anfang bis Ende?",
      "âœ“ Dateipfad exakt wie im Original?",
      "âœ“ Alle Imports vorhanden?",
      "âœ“ Alle Funktionen vorhanden?",
      "âœ“ Alle Klassen vorhanden?",
      "âœ“ EinrÃ¼ckung konsistent?",
      "âœ“ Keine Platzhalter oder Auslassungen?",
      "âœ“ Code ist lauffÃ¤hig?"
    ],
    
    "special_cases": {
      "new_file": "Bei neuen Dateien: VollstÃ¤ndigen Inhalt zeigen mit sinnvollem Pfad",
      "delete_file": "Explizit sagen: 'Datei X kann gelÃ¶scht werden' (keinen leeren Code-Block)",
      "rename_file": "Zwei Code-BlÃ¶cke: Alter Pfad (leer lassen) + Neuer Pfad (voller Inhalt)"
    }
  },

  "continuation_hint": "Starte deinen Prompt z.B. mit: 'Implementiere die Fenster-Erkennung. Zeige die KOMPLETTE market_tracker.py mit allen Ã„nderungen (keine Auslassungen).'"
}
